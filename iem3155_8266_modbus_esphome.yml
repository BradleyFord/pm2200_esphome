# ***************************************
# *     ESPHome Modbus config for       *
# *   Schneider iEM3155 Energy Meter    *
# ***************************************
#
# My iEM3155 config:
#
# Serial: 19200, EVEN, 1 (default)
# Slave address: 0x01
# Ensure that Com.Protection in the device is DISABLED !!
# Com.Protected is ENABLED by default !!
# Otherwise partial reset of daily energy import registers will be ignored
# by the device (id: daily_energy_import_total + 3 x daily_energy_import_lX)
#
# The devide also offers some additional interesting features that
# might be useful for others. Tariff/tariff rates and overload alarm.
# There's also both a digital input and output port that can be utilized
# as well.
# Check the iEM3155 user manual/technical datasheet for further info:
# https://download.schneider-electric.com/files?p_Doc_Ref=DOCA0005EN&p_enDocType=User+guide&p_File_Name=DOCA0005EN-13.pdf

esphome:
  name: iem3155-8266
  platform: ESP8266
  board: d1_mini
  # If daily_export_base value has not been retained on reboot (e.g. device power cycle) then set to current total export value.
  # If value has not been retained, then wait for 10 seconds after api connection and set value to current total export value.  
  on_boot:
    priority: -100
    then:
      - wait_until:
          api.connected:
      - delay: 10s
      - lambda: |-
          if (id(daily_export_base) == -1) {
            id(daily_export_base) = id(total_energy_export_total).state;
          }
      - component.update: daily_energy_export_total

globals:
  # Enable variable restore from RTC memory (ESP8266 only)
  # Daily export base variable will not survive a power cycle, only reboots.
  - id: daily_export_base
    type: float
    restore_value: yes
    initial_value: '-1'

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "your_api_password"

ota:
  password: "your_ota_password"

wifi:
  ssid: "your_ssid"
  password: "your_wifi_password"
  manual_ip:
    static_ip: xxx.xxx.xxx.xxx
    gateway: xxx.xxx.xxx.xxx
    subnet: xxx.xxx.xxx.xxx
    
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Iem3155-8266 Fallback Hotspot"
    password: "your_fallback_password"

captive_portal:

web_server:
  port: 80

time:
  - platform: homeassistant
    id: esptime
  - platform: sntp
    on_time:
      # Reset all four daily import counters at midnight
      # This will also force the command_result id to be updated
      # Validation check could be performed on command_result sensor
      # 0 = valid operation (reset all partial registers - ok)
      # 3000 = invalid operation (reset all partial registers - nok) )
      - seconds: 59
        minutes: 59
        hours: 23
        days_of_week: MON-SUN
        then:
          - component.update: iem3155_daily
      # Reset daily export base value at midnight
      # The iEM3155 unfortunately doesn't provide a partial export value register
      # Instead value is calculated using the total export register and export base value is reset at midnight
      - seconds: 00
        minutes: 00
        hours: 00
        days_of_week: MON-SUN
        then:
          - component.update: iem3155
          - lambda: |-
              id(daily_export_base) = id(total_energy_export_total).state;
          - component.update: daily_energy_export_total

binary_sensor:
  - platform: status
    name: "Energy Meter Status"
    id: system_status

uart:
  id: mod_bus
  rx_pin: 4 # D2
  tx_pin: 5 # D1
  baud_rate: 19200
  parity: EVEN
  stop_bits: 1
  # Optional debug parameter if rx/tx uart hex data is needed for debugging  
  #debug:

modbus:
  id: modbus1

modbus_controller:
  - id: iem3155
    address: 0x1
    modbus_id: modbus1
    # Update all, but Total Active, energy sensors every minute
    update_interval: 60s
    
  - id: iem3155_freq
    address: 0x1
    modbus_id: modbus1
    # Update Total Active Energy sensor frequently (10 seconds interval)
    update_interval: 10s  
  
  - id: iem3155_daily
    address: 0x1
    modbus_id: modbus1
    # No interval sensor update !
    # Only custom_command sensor is using this id (once daily at midnight)
    update_interval: never  
    
sensor:
  # Solar inverter sensor value for daily yield
  # Sensor needed for optional calculated  
  - platform: homeassistant
    id: daily_yield
    entity_id: sensor.solar_daily_yield
    internal: true
    filters:
      - multiply: 0.001

  - platform: template
    id: daily_energy_export_total
    name: "Daily Energy Export Total"
    device_class: energy
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    # In lambda check for initial export base variable value (-1)
    # Do not calculate daily export value if initial value is set. Instead return -1
    lambda: |-
      if (id(daily_export_base) == -1) {
        return -1;
      } else {
        return (id(total_energy_export_total).state - id(daily_export_base));
      }
    update_interval: 60s

  # Optional daily home consumption sensor
  # Value is calculated using solar daily yield sensor from HA    
  - platform: template
    id: daily_solar_consumption_total
    name: "Daily Solar Consumption Total"
    device_class: energy
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    lambda: |-
      return (id(daily_yield).state - id(daily_energy_export_total).state);
    update_interval: 60s

  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "L1 Active Power"
    id: power_l1
    register_type: holding
    address: 3053
    unit_of_measurement: "Wh"
    device_class: energy
    value_type: FP32
    filters:
      - multiply: 1000
    accuracy_decimals: 0
    
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "L2 Active Power"
    id: power_l2
    register_type: holding
    address: 3055
    unit_of_measurement: "Wh"
    device_class: energy
    value_type: FP32
    filters:
      - multiply: 1000
    accuracy_decimals: 0
    
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "L3 Active Power"
    id: power_l3
    register_type: holding
    address: 3057
    unit_of_measurement: "Wh"
    device_class: energy
    value_type: FP32
    filters:
      - multiply: 1000
    accuracy_decimals: 0
    
  - platform: modbus_controller
    modbus_controller_id: iem3155_freq
    name: "Total Active Power"
    id: power_total
    register_type: holding
    address: 3059
    unit_of_measurement: "Wh"
    device_class: energy
    value_type: FP32
    filters:
      - multiply: 1000
    accuracy_decimals: 0
   
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Power Factor"
    id: power_factor
    register_type: holding
    address: 3083
    value_type: FP32
    accuracy_decimals: 2
    ## Possible float values from: -2 to +1
    
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Energy Export Total"
    id: total_energy_export_total
    register_type: holding
    address: 45101
    unit_of_measurement: "kWh"
    device_class: energy
    # Set state_class in order for HA to use sensor in the Energy component
    state_class: total_increasing
    value_type: FP32
    accuracy_decimals: 3 
   
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Energy Import Total"
    id: total_energy_import_total
    register_type: holding
    address: 45099
    unit_of_measurement: "kWh"
    device_class: energy
    # Set state_class in order for HA to use sensor in the Energy component
    state_class: total_increasing
    value_type: FP32
    accuracy_decimals: 3 
  
    # Partial energy register used here as daily energy import sensor
    # Will be reset at midnight by custom_command
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Daily Energy Import Total"
    id: daily_energy_import_total
    register_type: holding
    address: 45107
    unit_of_measurement: "kWh"
    device_class: energy
    # Set state_class in order for HA to use sensor in the Energy component
    state_class: total_increasing 
    value_type: FP32
    accuracy_decimals: 3
    
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Daily Energy Import Phase 1"
    id: daily_energy_import_l1
    register_type: holding
    address: 45111
    unit_of_measurement: "kWh"
    value_type: FP32
    accuracy_decimals: 3
    
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Daily Energy Import Phase 2"
    id: daily_energy_import_l2
    register_type: holding
    address: 45113
    unit_of_measurement: "kWh"
    value_type: FP32
    accuracy_decimals: 3
    
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Daily Energy Import Phase 3"
    id: daily_energy_import_l3
    register_type: holding
    address: 45115
    unit_of_measurement: "kWh"
    value_type: FP32
    accuracy_decimals: 3
    
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Voltage avg. All Phases"
    id: voltage_avg
    register_type: holding
    address: 3035
    icon: mdi:SineWave
    unit_of_measurement: "V"
    value_type: FP32
    accuracy_decimals: 0
    
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Frequency"
    id: frequency
    register_type: holding
    address: 3109
    icon: mdi:SineWave
    unit_of_measurement: "Hz"
    value_type: FP32
    accuracy_decimals: 0
    
  - platform: modbus_controller
    modbus_controller_id: iem3155
    name: "Digital input control mode"
    id: digital_input
    # This register returns 5 if device partial energy readings
    # can be reset via digital input pins (12-40v dc pulse)
    # Alternative to the custom_command
    register_type: holding
    address: 7273
    value_type: U_WORD
  
  - platform: modbus_controller
    modbus_controller_id: iem3155_daily
    name: "Command result"
    id: command_result
    # Command Result codes:
    # 0 = Valid Operation
    # 3000 = Invalid Command
    # 3001 = Invalid Parameter
    # 3002 = Invalid Number of Parameters
    # 3007 = Operation Not Performed
    
    # This register returns 0 if daily import registers has been
    # reset correctly at midnight. Returns 3000 if device has
    # Com.Protection enabled
    # Sensor can be checked in HA to ensure partial counters
    # has been reset correctly
    register_type: holding
    address: 5375
    value_type: U_WORD
    
  - platform: modbus_controller
    modbus_controller_id: iem3155_daily
    name: "Reset command"
    id: reset_partial
    # custom_command to reset all partial energy readings just before midnight
    # Sensor value can't be used as result value. That has to be checked via command_result sensor
    # device slave address: 0x01
    # modbus command 16: 0x10
    # commmand register 5250 decimal: 0x1481 
    # number of registers to write: 0x0002 (write both command and command parameters registers)
    # number of bytes: 0x04 (2 parameters x 2 bytes)
    # command 2020 in register 5250: 0x07E4
    # command parameters in register 5252: 0x000 (this command has no parameters)
    custom_command: [ 0x01, 0x10, 0x14, 0x81, 0x00, 0x02, 0x04, 0x07, 0xE4, 0x00, 0x00 ]
    value_type: FP32
